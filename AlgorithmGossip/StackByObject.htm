<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>


    <link rel="stylesheet" href="css/stdlayout.css" type="text/css">


    <link rel="stylesheet" href="css/print.css" type="text/css">


    <meta content="text/html; charset=utf-8" http-equiv="content-type">


    <title>堆叠 - 使用 Java 作物件封装</title>
</head>


<body>


<h1><a href="AlgorithmGossip.htm">Algorithm Gossip:&nbsp;堆叠 - 使用 Java 作物件封装</a></h1>


<h2>说明</h2>

如果您使用C++或Java等支援物件导向的语言来实作堆叠，您可以使用类别的方式来包括堆叠的功能，将所有的堆叠操作由堆叠物件来处理，一旦包装完成，则使用堆叠物件的时候，只要呼叫加入、删除等方法，而无需处理堆叠的top或判断是否为空等细节。<br>

<h2>解法</h2>

使用C++与使用Java来作类别包装其实是类似的，在这边我们使用Java实作，因为它的语法看来较简洁；Java虽然没有指标，但可以使用参考（Reference）来达到链结的效果，一个节点的类别包装方式如下：<br>

<div style="margin-left: 40px;"><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">class Node { </span><br
        style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; private int data;&nbsp;&nbsp; // 节点资料 </span><br
            style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; private Node next;&nbsp; // 下一个节点位置 </span><br
            style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void setData(int data);&nbsp; // 节点资料 </span><br
            style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void setNext(Node next);&nbsp; // 下一个节点位置 </span><br
            style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public int getData();&nbsp; // 传回节点资料 </span><br
            style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public Node getNext();&nbsp; // 传回下一个节点位置 </span><br
            style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">}</span><br>

</div>

&nbsp;<br>

其中next是个物件参考名称，它可以用来参考至（指向）下一个节点物件的记忆体位置，而堆叠类别可以如下包装：<br>

<div style="margin-left: 40px;"><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">class Stack { </span><br
        style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; private Node top;&nbsp;&nbsp;&nbsp; // 堆叠顶端 </span><br
            style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; private String name;&nbsp; // 只是个名称 </span><br
            style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; // 利用建构子建立堆叠 </span><br
            style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public Stack(); </span><br
            style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public Stack(String name); </span><br
            style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; // 插入资料至顶端 </span><br
            style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void add(int data); </span><br
            style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; // 传回顶端资料 </span><br
            style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public int printTop(); </span><br
            style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; // 删除顶端资料 </span><br
            style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void del(); </span><br
            style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; // 列出堆叠内容 </span><br
            style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void list(); </span><br
            style="font-weight: bold; font-family: Courier New,Courier,monospace;">

    <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">}</span><br>

</div>

&nbsp;<br>

利用物件导向来包装资料结构，虽然在设计时需要花较多的心思，但设计完成之后，日后呼叫使用就简单了，以后您只要注意主程式的逻辑设计就可以了。<br>


<br>

<h2> 实作</h2>


<ul>

    <li> Java
    </li>

</ul>


<pre>import java.io.*; <br><br>// 节点 <br>class Node { <br>    private int data;   // 节点资料 <br>    private Node next;  // 下一个节点位置 <br><br>    public void setData(int data) {  // 节点资料 <br>        this.data = data; <br>    } <br><br>    public void setNext(Node next) {  // 下一个节点位置 <br>        this.next = next; <br>    } <br><br>    public int getData() {  // 传回节点资料 <br>        return data; <br>    } <br><br>    public Node getNext() {  // 传回下一个节点位置 <br>        return next; <br>    } <br>} <br><br>// 堆叠 <br>class Stack { <br>    private Node top; <br>    private String name;  // 只是个名称 <br><br>    public Stack() { <br>        this("list"); <br>    } <br><br>    // 利用建构子建立堆叠 <br>    public Stack(String name) { <br>        this.name = name; <br>        top = null; <br>    } <br><br>    // 插入资料至顶端 <br>    public void add(int data) { <br>        Node newNode = new Node(); <br>        newNode.setData(data); <br>        newNode.setNext(top); <br>        top = newNode; <br>    } <br><br>    // 传回顶端资料 <br>    public int printTop() { <br>        return top.getData(); <br>    } <br><br>    // 删除顶端资料 <br>    public void del() { <br>        Node tmpNode; <br>        tmpNode = top; <br><br>        if(tmpNode == null) { <br>            System.out.println("\n堆叠已空！"); <br>            return; <br>        } <br><br>        top = top.getNext(); <br>        tmpNode = null; <br>    } <br><br>    // 列出堆叠内容 <br>    public void list() { <br>        Node tmpNode; <br>        tmpNode = top; <br><br>        System.out.print("\n堆叠内容："); <br>        while(tmpNode != null) { <br>            System.out.print(tmpNode.getData() + " "); <br>            tmpNode = tmpNode.getNext(); <br>        } <br>    } <br>} <br><br>public class StackShow { <br>    public static void main(String[] args) <br>                                  throws IOException { <br>        int input, select; <br>        BufferedReader buf; <br>        buf = new BufferedReader(<br>                       new InputStreamReader(System.in)); <br><br>        Stack s1 = new Stack("堆叠测试"); <br><br>        while(true) {  <br>            System.out.print("\n\n请输入选项(-1结束)："); <br>            System.out.print("\n(1)插入值至堆叠"); <br>            System.out.print("\n(2)显示堆叠顶端"); <br>            System.out.print("\n(3)删除顶端值"); <br>            System.out.print("\n(4)显示所有内容"); <br>            System.out.print("\n$c&gt;"); <br><br>            select = Integer.parseInt(buf.readLine()); <br><br>            if(select == -1) <br>                break; <br><br>            switch(select) { <br>                case 1: <br>                    System.out.print("\n输入值："); <br>                    input = Integer.parseInt(buf.readLine()); <br>                    s1.add(input); <br>                    break; <br>                case 2: <br>                    System.out.print("\n顶端值：" +  <br>                                             s1.printTop()); <br>                    break; <br>                case 3: <br>                    s1.del(); <br>                    break; <br>                case 4: <br>                    s1.list(); <br>                    break; <br>                default: <br>                    System.out.print("\n选项错误！"); <br>            } <br>        } <br><br>        System.out.println(""); <br>    } <br>}</pre>

<br>


</body>
</html>
